<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CLion Tests with Nucleo G0 | mdnj</title>
<meta name=keywords content><meta name=description content="CLion Tests with Nucleo G0
CLion Test in Embedded Development
Current Experience with Different Environments and Editors
Recently, I had the chance to work in the CLion environment, so I decided to test it out in the context of Embedded development. I used CLion for a mini-project for university in C++, and it was great to write in, so I figured it would be worth trying it out for an Embedded project too. My experiences with different IDEs for Embedded, like CubeIDE, CrossStudio, or VSC with extensions, haven&rsquo;t been too impressive so far (they were okay, but something was always missing). I usually work with STM32 processors. The goal was to see if CLion makes debugging and code writing easier (one IDE without extra editors). I also wanted to avoid using OpenOCD (it doesn&rsquo;t always seem like a stable solution to me â€“ I&rsquo;ve had bad experiences debugging Zephyr on Windows)."><meta name=author content="MichaÅ‚ Dunajski"><link rel=canonical href=https://dunajski.github.io/en/posts/2025-05-03-go-clion-post-en/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://dunajski.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dunajski.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dunajski.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dunajski.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dunajski.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dunajski.github.io/en/posts/2025-05-03-go-clion-post-en/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dunajski.github.io/en/posts/2025-05-03-go-clion-post-en/"><meta property="og:site_name" content="mdnj"><meta property="og:title" content="CLion Tests with Nucleo G0"><meta property="og:description" content="CLion Tests with Nucleo G0 CLion Test in Embedded Development Current Experience with Different Environments and Editors Recently, I had the chance to work in the CLion environment, so I decided to test it out in the context of Embedded development. I used CLion for a mini-project for university in C++, and it was great to write in, so I figured it would be worth trying it out for an Embedded project too. My experiences with different IDEs for Embedded, like CubeIDE, CrossStudio, or VSC with extensions, havenâ€™t been too impressive so far (they were okay, but something was always missing). I usually work with STM32 processors. The goal was to see if CLion makes debugging and code writing easier (one IDE without extra editors). I also wanted to avoid using OpenOCD (it doesnâ€™t always seem like a stable solution to me â€“ Iâ€™ve had bad experiences debugging Zephyr on Windows)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CLion Tests with Nucleo G0"><meta name=twitter:description content="CLion Tests with Nucleo G0
CLion Test in Embedded Development
Current Experience with Different Environments and Editors
Recently, I had the chance to work in the CLion environment, so I decided to test it out in the context of Embedded development. I used CLion for a mini-project for university in C++, and it was great to write in, so I figured it would be worth trying it out for an Embedded project too. My experiences with different IDEs for Embedded, like CubeIDE, CrossStudio, or VSC with extensions, haven&rsquo;t been too impressive so far (they were okay, but something was always missing). I usually work with STM32 processors. The goal was to see if CLion makes debugging and code writing easier (one IDE without extra editors). I also wanted to avoid using OpenOCD (it doesn&rsquo;t always seem like a stable solution to me â€“ I&rsquo;ve had bad experiences debugging Zephyr on Windows)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dunajski.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"CLion Tests with Nucleo G0","item":"https://dunajski.github.io/en/posts/2025-05-03-go-clion-post-en/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CLion Tests with Nucleo G0","name":"CLion Tests with Nucleo G0","description":"CLion Tests with Nucleo G0 CLion Test in Embedded Development Current Experience with Different Environments and Editors Recently, I had the chance to work in the CLion environment, so I decided to test it out in the context of Embedded development. I used CLion for a mini-project for university in C++, and it was great to write in, so I figured it would be worth trying it out for an Embedded project too. My experiences with different IDEs for Embedded, like CubeIDE, CrossStudio, or VSC with extensions, haven\u0026rsquo;t been too impressive so far (they were okay, but something was always missing). I usually work with STM32 processors. The goal was to see if CLion makes debugging and code writing easier (one IDE without extra editors). I also wanted to avoid using OpenOCD (it doesn\u0026rsquo;t always seem like a stable solution to me â€“ I\u0026rsquo;ve had bad experiences debugging Zephyr on Windows).\n","keywords":[],"articleBody":"CLion Tests with Nucleo G0 CLion Test in Embedded Development Current Experience with Different Environments and Editors Recently, I had the chance to work in the CLion environment, so I decided to test it out in the context of Embedded development. I used CLion for a mini-project for university in C++, and it was great to write in, so I figured it would be worth trying it out for an Embedded project too. My experiences with different IDEs for Embedded, like CubeIDE, CrossStudio, or VSC with extensions, havenâ€™t been too impressive so far (they were okay, but something was always missing). I usually work with STM32 processors. The goal was to see if CLion makes debugging and code writing easier (one IDE without extra editors). I also wanted to avoid using OpenOCD (it doesnâ€™t always seem like a stable solution to me â€“ Iâ€™ve had bad experiences debugging Zephyr on Windows).\nIn CubeIDE, the sluggish performance annoyed me, but on the flip side, when generating a project directly from CubeIDE (using the environmentâ€™s wizards), the project worked right away. I mean, after creating it and clicking â€˜Buildâ€™, and then â€˜Runâ€™/â€˜Debugâ€™, the debugging session or firmware upload just happened without having to mess around with settings. That doesnâ€™t change the fact that I find it hard to write in CubeIDE (Iâ€™m used to Visual Studio Code), so I ended up writing code in VSC and debugging it in CubeIDE. Recently, CubeMX added the ability to generate CMake-type projects, which came in handy when I was doing my CLion tests.\nUsing Visual Studio Code was the opposite: I was familiar with writing and reading code in that editor, but setting up the debugger requires a few steps that boil down to editing a couple of .json files.\nCrossStudio is similar to STM32CubeIDE for me, except that generating a project prevents you from using the manufacturerâ€™s libraries directly in the project generator. This can be a bit of a problem if (like me) you usually need those libraries because you want to test something and not necessarily write a whole complex application from scratch. CrossStudio runs faster than CubeIDE and also has a convenient setup with the STM debugger.\nMini-Test The test setup was as follows:\nNucleo G071RB (link to board) CLion 2025.1 (link to CLion) STM32CubeCLT (link to STM32CubeCLT) STM32CubeMX 6.14.1 (link to STM32CubeMX) arm-none-eabi-gcc 10.3 (link to gcc) My old, unfinished (ðŸ˜…) football timer project [repository] Windows 11 I already had CubeMX and CLion installed. CLion suggested I install CubeCLT to generate the project correctly.\nAs Iâ€™m writing this, JetBrains is introducing new features for Embedded Development, especially for STM32. Itâ€™ll be worth testing them out in the future to fairly compare the capabilities.\nI started by reading the documentation on running projects from a .ioc file (link to section). However, it seems to me that this method will soon become obsolete, considering that CubeMX now allows generating projects with the CMake toolchain. The method from the JetBrains documentation didnâ€™t work correctly, so I decided to try the one available directly in CLion. After selecting the option File -\u003e New -\u003e Project -\u003e STM32CubeMX, a window popped up that allowed me to load the project. It worked without any issues, but it works best for new projects generated by CubeMX where the CMake toolchain was selected from the start.\nClean Project vs. Old Project If you have the option, try testing CLion on fresh projects with the CMake toolchain selected. In my case, I had to take a few steps in CubeMX: I saved my old project in a new location, changed the toolchain to CMake, and regenerated the project. I also manually added the files to CMakeLists.txt.\n# Add sources to executable target_sources(${CMAKE_PROJECT_NAME} PRIVATE # Add user sources here ${CMAKE_SOURCE_DIR}/Core/Src/buttons.c ${CMAKE_SOURCE_DIR}/Core/Src/menus.c ${CMAKE_SOURCE_DIR}/Core/Src/game.c ) Debugging After a few minor issues with CLion, CMake, and CubeMX, I finally managed to build the project (the default is ctrl + shift + B in CLion). Then, I configured a debug session using the ST-Link GDB server, which turned out to be extremely helpful thanks to the JetBrains documentation.\nUsing the New Embedded GDB Server Run Configuration window, I created a configuration that started the debug session when I pressed F5. My configuration was named stm-gdb, and now pressing F5 starts the debug session. I also had to add the .svd file from the manufacturer to be able to view the MCU register values in the Peripherals tab.\nEvaluation Iâ€™d give my initial evaluation of CLion tests in Embedded using Nucleo G071RB and STM32CubeMX a 4/5. After some initial configuration hiccups, CLion provides convenient tools for writing and debugging code. Similar environments (like CubeIDE) offer easier debugger configuration, but CLion works well, especially with CMake-based projects. I canâ€™t give it a higher rating because CLion crashed a few times when switching projects, and things werenâ€™t as smooth for an existing (non-new) project.\nThat said, the tests were pretty superficial, so to have a more solid opinion, Iâ€™d need to spend more time using CLion. Which doesnâ€™t change the fact that I intend to use it for future projects now, and Iâ€™m not discouraged.\n","wordCount":"858","inLanguage":"en","datePublished":"2025-05-03T00:00:00Z","dateModified":"2025-05-03T00:00:00Z","author":{"@type":"Person","name":"MichaÅ‚ Dunajski"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dunajski.github.io/en/posts/2025-05-03-go-clion-post-en/"},"publisher":{"@type":"Organization","name":"mdnj","logo":{"@type":"ImageObject","url":"https://dunajski.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dunajski.github.io/en/ accesskey=h title="mdnj (Alt + H)">mdnj</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://dunajski.github.io/pl/ title=Polski aria-label=Polski>Pl</a></li></ul></div></div><ul id=menu><li><a href=https://dunajski.github.io/en/about/ title=About><span>About</span></a></li><li><a href=https://dunajski.github.io/en/posts/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CLion Tests with Nucleo G0</h1><div class=post-meta><span title='2025-05-03 00:00:00 +0000 UTC'>May 3, 2025</span>&nbsp;Â·&nbsp;MichaÅ‚ Dunajski</div></header><div class=post-content><h2 id=clion-tests-with-nucleo-g0>CLion Tests with Nucleo G0<a hidden class=anchor aria-hidden=true href=#clion-tests-with-nucleo-g0>#</a></h2><h3 id=clion-test-in-embedded-development>CLion Test in Embedded Development<a hidden class=anchor aria-hidden=true href=#clion-test-in-embedded-development>#</a></h3><h4 id=current-experience-with-different-environments-and-editors>Current Experience with Different Environments and Editors<a hidden class=anchor aria-hidden=true href=#current-experience-with-different-environments-and-editors>#</a></h4><p>Recently, I had the chance to work in the CLion environment, so I decided to test it out in the context of Embedded development. I used CLion for a mini-project for university in C++, and it was great to write in, so I figured it would be worth trying it out for an Embedded project too. My experiences with different IDEs for Embedded, like CubeIDE, CrossStudio, or VSC with extensions, haven&rsquo;t been too impressive so far (they were okay, but something was always missing). I usually work with STM32 processors. The goal was to see if CLion makes debugging and code writing easier (one IDE without extra editors). I also wanted to avoid using OpenOCD (it doesn&rsquo;t always seem like a stable solution to me â€“ I&rsquo;ve had bad experiences debugging Zephyr on Windows).</p><p>In CubeIDE, the sluggish performance annoyed me, but on the flip side, when generating a project directly from CubeIDE (using the environment&rsquo;s wizards), the project worked right away. I mean, after creating it and clicking &lsquo;Build&rsquo;, and then &lsquo;Run&rsquo;/&lsquo;Debug&rsquo;, the debugging session or firmware upload just happened without having to mess around with settings. That doesn&rsquo;t change the fact that I find it hard to write in CubeIDE (I&rsquo;m used to Visual Studio Code), so I ended up writing code in VSC and debugging it in CubeIDE. Recently, CubeMX added the ability to generate CMake-type projects, which came in handy when I was doing my CLion tests.</p><p>Using Visual Studio Code was the opposite: I was familiar with writing and reading code in that editor, but setting up the debugger requires a few steps that boil down to editing a couple of .json files.</p><p>CrossStudio is similar to STM32CubeIDE for me, except that generating a project prevents you from using the manufacturer&rsquo;s libraries directly in the project generator. This can be a bit of a problem if (like me) you usually need those libraries because you want to test something and not necessarily write a whole complex application from scratch. CrossStudio runs faster than CubeIDE and also has a convenient setup with the STM debugger.</p><h3 id=mini-test>Mini-Test<a hidden class=anchor aria-hidden=true href=#mini-test>#</a></h3><p>The test setup was as follows:</p><ul><li><strong>Nucleo G071RB</strong> (<a href=https://www.st.com/en/evaluation-tools/nucleo-g071rb.html>link to board</a>)</li><li><strong>CLion 2025.1</strong> (<a href=https://www.jetbrains.com/clion/>link to CLion</a>)</li><li><strong>STM32CubeCLT</strong> (<a href=https://www.st.com/en/development-tools/stm32cubeclt.html>link to STM32CubeCLT</a>)</li><li><strong>STM32CubeMX 6.14.1</strong> (<a href=https://www.st.com/en/development-tools/stm32cubemx.html>link to STM32CubeMX</a>)</li><li><strong>arm-none-eabi-gcc 10.3</strong> (<a href=https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain>link to gcc</a>)</li><li>My old, unfinished (ðŸ˜…) football timer project [<a href=https://github.com/dunajski/football_timer>repository</a>]</li><li><strong>Windows 11</strong></li></ul><p>I already had CubeMX and CLion installed. CLion suggested I install CubeCLT to generate the project correctly.</p><blockquote><p>As I&rsquo;m writing this, JetBrains is introducing new features for Embedded Development, especially for STM32. It&rsquo;ll be worth testing them out in the future to fairly compare the capabilities.</p></blockquote><p>I started by reading the documentation on running projects from a <code>.ioc</code> file (<a href="https://www.jetbrains.com/help/clion/2025.1/embedded-development.html?Embedded_Development&amp;keymap=VSCode#open-project">link to section</a>). However, it seems to me that this method will soon become obsolete, considering that CubeMX now allows generating projects with the CMake toolchain. <img alt=cube_mx_wybor_toolchaina loading=lazy src=/images/cube_mx_cmake.png></p><p>The method from the JetBrains documentation didn&rsquo;t work correctly, so I decided to try the one available directly in CLion. After selecting the option <strong>File -> New -> Project -> STM32CubeMX</strong>, a window popped up that allowed me to load the project. It worked without any issues, but it works best for new projects generated by CubeMX where the CMake toolchain was selected from the start.</p><h4 id=clean-project-vs-old-project>Clean Project vs. Old Project<a hidden class=anchor aria-hidden=true href=#clean-project-vs-old-project>#</a></h4><p>If you have the option, try testing CLion on fresh projects with the CMake toolchain selected. In my case, I had to take a few steps in CubeMX: I saved my old project in a new location, changed the toolchain to CMake, and regenerated the project. I also manually added the files to CMakeLists.txt.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e># Add sources to executable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>target_sources</span>(<span style=color:#960050;background-color:#1e0010>$</span>{CMAKE_PROJECT_NAME} PRIVATE
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add user sources here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#960050;background-color:#1e0010>$</span>{CMAKE_SOURCE_DIR}<span style=color:#f92672>/</span>Core<span style=color:#f92672>/</span>Src<span style=color:#f92672>/</span>buttons.c
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>$</span>{CMAKE_SOURCE_DIR}<span style=color:#f92672>/</span>Core<span style=color:#f92672>/</span>Src<span style=color:#f92672>/</span>menus.c
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>$</span>{CMAKE_SOURCE_DIR}<span style=color:#f92672>/</span>Core<span style=color:#f92672>/</span>Src<span style=color:#f92672>/</span>game.c
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=debugging>Debugging<a hidden class=anchor aria-hidden=true href=#debugging>#</a></h3><p>After a few minor issues with CLion, CMake, and CubeMX, I finally managed to build the project (the default is <code>ctrl + shift + B</code> in CLion). Then, I configured a debug session using the ST-Link GDB server, which turned out to be extremely helpful thanks to the <a href="https://www.jetbrains.com/help/clion/2025.1/embedded-gdb-server.html?Embedded_Development&amp;keymap=VSCode&amp;utm_source=product&amp;utm_medium=link&amp;utm_campaign=CL&amp;utm_content=2025.1">JetBrains documentation</a>.</p><p>Using the <strong>New Embedded GDB Server Run Configuration</strong> window, I created a configuration that started the debug session when I pressed F5. <img alt=new_emb_gdb_server loading=lazy src=/images/new_emb_gdb_server.png></p><p>My configuration was named <code>stm-gdb</code>, and now pressing F5 starts the debug session. <img alt=debug_session loading=lazy src=/images/debug_session.png></p><p>I also had to add the .svd file from the manufacturer to be able to view the MCU register values in the <strong>Peripherals</strong> tab.</p><h3 id=evaluation>Evaluation<a hidden class=anchor aria-hidden=true href=#evaluation>#</a></h3><p>I&rsquo;d give my initial evaluation of CLion tests in Embedded using Nucleo G071RB and STM32CubeMX a <strong>4/5</strong>. After some initial configuration hiccups, CLion provides convenient tools for writing and debugging code. Similar environments (like CubeIDE) offer easier debugger configuration, but CLion works well, especially with CMake-based projects. I can&rsquo;t give it a higher rating because CLion crashed a few times when switching projects, and things weren&rsquo;t as smooth for an existing (non-new) project.</p><p>That said, the tests were pretty superficial, so to have a more solid opinion, I&rsquo;d need to spend more time using CLion. Which doesn&rsquo;t change the fact that I intend to use it for future projects now, and I&rsquo;m not discouraged.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dunajski.github.io/en/>mdnj</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>